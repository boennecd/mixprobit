# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

pmvnorm_cpp <- function(lower, upper, mean, cov, maxpts, abseps, releps) {
    .Call('_mixprobit_pmvnorm_cpp', PACKAGE = 'mixprobit', lower, upper, mean, cov, maxpts, abseps, releps)
}

pmvnorm_cpp_restrict <- function(mean, cov, maxpts, abseps, releps, gradient = FALSE, minvls = 0L) {
    .Call('_mixprobit_pmvnorm_cpp_restrict', PACKAGE = 'mixprobit', mean, cov, maxpts, abseps, releps, gradient, minvls)
}

aprx_binary_mix <- function(y, eta, Z, Sigma, maxpts, abseps, releps, key = 2L, is_adaptive = FALSE) {
    .Call('_mixprobit_aprx_binary_mix', PACKAGE = 'mixprobit', y, eta, Z, Sigma, maxpts, abseps, releps, key, is_adaptive)
}

aprx_mult_mix <- function(n_alt, eta, Z, Sigma, maxpts, abseps, releps, key = 2L, is_adaptive = FALSE) {
    .Call('_mixprobit_aprx_mult_mix', PACKAGE = 'mixprobit', n_alt, eta, Z, Sigma, maxpts, abseps, releps, key, is_adaptive)
}

aprx_jac_binary_mix <- function(y, eta, X, Z, Sigma, maxpts, abseps, releps, key = 2L, is_adaptive = FALSE) {
    .Call('_mixprobit_aprx_jac_binary_mix', PACKAGE = 'mixprobit', y, eta, X, Z, Sigma, maxpts, abseps, releps, key, is_adaptive)
}

aprx_binary_mix_cdf <- function(y, eta, Z, Sigma, maxpts, abseps, releps) {
    .Call('_mixprobit_aprx_binary_mix_cdf', PACKAGE = 'mixprobit', y, eta, Z, Sigma, maxpts, abseps, releps)
}

aprx_mult_mix_cdf <- function(n_alt, eta, Z, Sigma, maxpts, abseps, releps) {
    .Call('_mixprobit_aprx_mult_mix_cdf', PACKAGE = 'mixprobit', n_alt, eta, Z, Sigma, maxpts, abseps, releps)
}

aprx_binary_mix_cdf_get_ptr <- function(data, n_threads, gradient = FALSE, minvls = 0L) {
    .Call('_mixprobit_aprx_binary_mix_cdf_get_ptr', PACKAGE = 'mixprobit', data, n_threads, gradient, minvls)
}

aprx_binary_mix_cdf_eval <- function(ptr, beta, log_sds, maxpts, abseps, releps) {
    .Call('_mixprobit_aprx_binary_mix_cdf_eval', PACKAGE = 'mixprobit', ptr, beta, log_sds, maxpts, abseps, releps)
}

set_GH_rule_cached <- function(b) {
    .Call('_mixprobit_set_GH_rule_cached', PACKAGE = 'mixprobit', b)
}

aprx_binary_mix_ghq <- function(y, eta, Z, Sigma, b, is_adaptive = FALSE) {
    .Call('_mixprobit_aprx_binary_mix_ghq', PACKAGE = 'mixprobit', y, eta, Z, Sigma, b, is_adaptive)
}

aprx_mult_mix_ghq <- function(n_alt, eta, Z, Sigma, b, is_adaptive = FALSE) {
    .Call('_mixprobit_aprx_mult_mix_ghq', PACKAGE = 'mixprobit', n_alt, eta, Z, Sigma, b, is_adaptive)
}

aprx_binary_mix_qmc <- function(y, eta, Z, Sigma, n_max, seeds, releps, is_adaptive = FALSE) {
    .Call('_mixprobit_aprx_binary_mix_qmc', PACKAGE = 'mixprobit', y, eta, Z, Sigma, n_max, seeds, releps, is_adaptive)
}

aprx_mult_mix_qmc <- function(n_alt, eta, Z, Sigma, n_max, seeds, releps, is_adaptive = FALSE) {
    .Call('_mixprobit_aprx_mult_mix_qmc', PACKAGE = 'mixprobit', n_alt, eta, Z, Sigma, n_max, seeds, releps, is_adaptive)
}

aprx_binary_mix_brute <- function(y, eta, Z, Sigma, n_sim, n_threads = 1L, is_is = TRUE) {
    .Call('_mixprobit_aprx_binary_mix_brute', PACKAGE = 'mixprobit', y, eta, Z, Sigma, n_sim, n_threads, is_is)
}

aprx_mult_mix_brute <- function(n_alt, eta, Z, Sigma, n_sim, n_threads = 1L, is_is = TRUE) {
    .Call('_mixprobit_aprx_mult_mix_brute', PACKAGE = 'mixprobit', n_alt, eta, Z, Sigma, n_sim, n_threads, is_is)
}

for_rngnorm_wrapper_test <- function(n, n_threads) {
    .Call('_mixprobit_for_rngnorm_wrapper_test', PACKAGE = 'mixprobit', n, n_threads)
}

my_pmvnorm_cpp <- function(mean_in, sigma_in, nsim, eps) {
    .Call('_mixprobit_my_pmvnorm_cpp', PACKAGE = 'mixprobit', mean_in, sigma_in, nsim, eps)
}

get_sobol_obj <- function(dimen, scrambling = 0L, seed = 4711L) {
    .Call('_mixprobit_get_sobol_obj', PACKAGE = 'mixprobit', dimen, scrambling, seed)
}

eval_sobol <- function(n, ptr) {
    .Call('_mixprobit_eval_sobol', PACKAGE = 'mixprobit', n, ptr)
}

multinomial_inner_integral <- function(Z, eta, Sigma, n_nodes, is_adaptive, n_times, u, order = 0L) {
    .Call('_mixprobit_multinomial_inner_integral', PACKAGE = 'mixprobit', Z, eta, Sigma, n_nodes, is_adaptive, n_times, u, order)
}

