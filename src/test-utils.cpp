#include <testthat.h>
#include <limits>
#include "utils.h"

context("utils tests") {
  test_that("dcond_vcov works as expected") {
    /*
     set.seed(1)
     n <- 5L
     k <- 2L
     Sigma <- drop(rWishart(1, 2L * n, diag(n)))
     Z <- matrix(rnorm(n * k), k)

     dput(Sigma)
     dput(crossprod(Z))

     get_H <- \(x) crossprod(Z) + solve(matrix(x, n, n))
     g <- \(x) sum(exp(x))
     f <- \(x) get_H(x) |> solve() |> g()

     f(Sigma)
     library(numDeriv)
     dF <- grad(f, Sigma)

     H_inv <- get_H(Sigma) |> solve()
     dH_inv <- grad(g, H_inv)
     dput(dH_inv)

     H <- get_H(Sigma)
     comp_res <- matrix(dH_inv, n) |>
     solve(a = H) |>
     solve(a = Sigma) |>
     t() |>
     solve(a = H) |>
     solve(a = Sigma)

     all.equal(c(comp_res), dF)

     dput(comp_res)
     */
    constexpr arma::uword n{5};

    arma::mat Sigma{6.53840376244045, 3.25364028156331, -3.93769885961481, 1.47229034065976, -1.58853096462909, 3.25364028156331, 15.8224564695579, -5.45900271436491, -0.418287500907006, -9.13710658458838, -3.93769885961481, -5.45900271436491, 11.8710928151963, 3.83994392481692, 6.31928920340362, 1.47229034065976, -0.418287500907006, 3.83994392481692, 7.73275702834141, 1.91859396027026, -1.58853096462909, -9.13710658458838, 6.31928920340362, 1.91859396027026, 12.8671054809489},
                  K{0.891088917219998, 0.547249785327857, 0.723330076893113, -1.87882939304271, -0.0630114787615107, 0.547249785327857, 1.02712303062224, 1.21919547775656, -1.12024425578792, 0.475679108874113, 0.723330076893113, 1.21919547775656, 1.45625660244923, -1.4874206438287, 0.525705511955469, -1.87882939304271, -1.12024425578792, -1.4874206438287, 3.96308010657873, 0.157877099749777, -0.0630114787615107, 0.475679108874113, 0.525705511955469, 0.157877099749777, 0.387334393154351},
             dH_inv{484.444947170403, 16.4789307714358, 0.0883098397142331, 16.3264143375452, 0.634059475655878, 16.4789307714358, 152115.657221066, 0.00493508350902881, 17.166830926361, 0.000365883567707474, 0.088309839714233, 0.00493508350902882, 90.1916462857063, 0.395603576291986, 4.00766354829859, 16.3264143375452, 17.166830926361, 0.395603576291987, 7.92756177857831, 0.112148676957492, 0.634059475655869, 0.000365883567707474, 4.00766354829859, 0.112148676957492, 10318.546358946},
        true_derivs{18655.1616963039, -33367.5623913086, 23174.7753743168, -38005.4937320917, 6381.80831452317, -33367.5623913086, 61645.621069475, -43355.6381075457, 69729.7302571997, -10074.655975296, 23174.7753743168, -43355.6381075457, 31265.7694272985, -48303.5189011489, 4981.5941609135, -38005.4937320916, 69729.7302571997, -48303.5189011489, 79580.7455091153, -13402.319153896, 6381.80831452315, -10074.655975296, 4981.5941609135, -13402.3191538959, 7413.53805601633};

    Sigma.reshape(n, n);
    K.reshape(n, n);
    dH_inv.reshape(n, n);
    true_derivs.reshape(n, n);

    arma::mat H{K + arma::inv_sympd(Sigma)};

    auto res = dcond_vcov(H, dH_inv, Sigma);
    expect_true(res.n_rows == n);
    expect_true(res.n_cols == n);

    auto const eps = std::sqrt(std::numeric_limits<double>::epsilon());
    for(arma::uword j = 0; j < n; ++j)
      for(arma::uword i = 0; i < n; ++i)
        expect_true(std::abs(res(i, j) - true_derivs(i, j)) <
          eps * std::abs(true_derivs(i, j)));
  }

  test_that("dcond_vcov_rev works"){
    /*
     set.seed(1)
     n <- 4L
     k <- 3L
     b <- 5L
     Psi <- drop(rWishart(1, n, diag(n)))
     Z <- rnorm(n * k) |> matrix(n)
     v <- rnorm(k)
     L <- rnorm(b * k) |> matrix(b)

     f <- \(x){
     P <- matrix(x, n)
     L %*% solve(diag(k) + crossprod(Z, P %*% Z), v) |>
     drop()
     }
     g <- \(x) sin(x) |> sum()
     h <- \(x) f(x) |> g()

     truth <- numDeriv::grad(h, Psi)

     d_g <- f(Psi) |> cos() |> drop()
     K <- diag(k) + crossprod(Z, Psi %*% Z)
     x1 <- Z %*% solve(K, crossprod(L, d_g)) |> drop()
     x2 <- Z %*% solve(K, v) |> drop()

     all.equal(-x1 %o% x2 |> c(), truth)

     dput(Psi)
     dput(Z)
     dput(v)
     dput(d_g)
     dput(L)
     -x1 %o% x2 |> c() |> dput()
     */
    constexpr arma::uword n{4}, k{3}, b{5};

    arma::mat Psi{1.66173000475602, 1.64026455103121, -1.98512044759873, -0.00743435321565165, 1.64026455103121, 7.16285794371291, -4.14581062030046, 5.65447492748679, -1.98512044759873, -4.14581062030046, 4.90603816923005, -1.23652487489528, -0.00743435321565165, 5.65447492748679, -1.23652487489528, 6.77907155498759};
    Psi.reshape(n, n);
    arma::mat Z{-0.799009248989368, -1.14765700923635, -0.289461573688223, -0.299215117897316, -0.411510832795067, 0.252223448156132, -0.891921127284569, 0.435683299355719, -1.23753842192996, -0.224267885278309, 0.377395645981701, 0.133336360814841};
    Z.reshape(n, k);
    arma::mat L{1.08576936214569, -0.69095383969683, -1.28459935387219, 0.046726172188352, -0.235706556439501, -0.542888255010254, -0.433310317456782, -0.649471646796233, 0.726750747385451, 1.1519117540872, 0.992160365445798, -0.429513109491881, 1.23830410085338, -0.279346281854269, 1.75790308981071};
    L.reshape(b, k);
    arma::vec const v{0.804189509744908, -0.0571067743838088, 0.503607972233726},
                  d_g{0.99426351289398, 0.984164784423779, 0.98081734006309, 0.994636455007448, 0.970189995034326};

    arma::mat K = Z.t() * Psi * Z;
    K.diag() += 1;
    auto const res = dcond_vcov_rev(K, Z, L, v, d_g);

    expect_true(res.n_rows == n);
    expect_true(res.n_cols == n);

    constexpr double expec[]{-0.1441515048045, 0.0573205033533364, 0.0819200518941111, 0.0490186544412012, -0.0733941351105438, 0.0291844942820731, 0.0417092514235861, 0.0249576426682039, -0.0959146806496801, 0.0381395794741823, 0.0545074824358242, 0.0326157440602596, 0.0229736883486663, -0.00913527321004511, -0.013055748146884, -0.00781219240083836};

    for(arma::uword j = 0; j < n; ++j)
      for(arma::uword i = 0; i < n; ++i)
        expect_true(
          std::abs(res(i, j) - expec[i + j * n]) <
            1e-6 * std::abs(expec[i + j * n]));
  }
}
